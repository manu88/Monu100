   1               		.file	"usb_debug_only.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.usb_wait_in_ready,"ax",@progbits
  13               	usb_wait_in_ready:
  14               	.LFB6:
  15               		.file 1 "usb_debug_only.c"
   1:usb_debug_only.c **** /* USB Debug Channel Example for Teensy USB Development Board
   2:usb_debug_only.c ****  * http://www.pjrc.com/teensy/
   3:usb_debug_only.c ****  * Copyright (c) 2008 PJRC.COM, LLC
   4:usb_debug_only.c ****  * 
   5:usb_debug_only.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   6:usb_debug_only.c ****  * of this software and associated documentation files (the "Software"), to deal
   7:usb_debug_only.c ****  * in the Software without restriction, including without limitation the rights
   8:usb_debug_only.c ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:usb_debug_only.c ****  * copies of the Software, and to permit persons to whom the Software is
  10:usb_debug_only.c ****  * furnished to do so, subject to the following conditions:
  11:usb_debug_only.c ****  * 
  12:usb_debug_only.c ****  * The above copyright notice and this permission notice shall be included in
  13:usb_debug_only.c ****  * all copies or substantial portions of the Software.
  14:usb_debug_only.c ****  * 
  15:usb_debug_only.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:usb_debug_only.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:usb_debug_only.c ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:usb_debug_only.c ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:usb_debug_only.c ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:usb_debug_only.c ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:usb_debug_only.c ****  * THE SOFTWARE.
  22:usb_debug_only.c ****  */
  23:usb_debug_only.c **** 
  24:usb_debug_only.c **** // Version 1.0: Initial Release
  25:usb_debug_only.c **** // Version 1.1: Add support for Teensy 2.0
  26:usb_debug_only.c **** 
  27:usb_debug_only.c **** #define USB_SERIAL_PRIVATE_INCLUDE
  28:usb_debug_only.c **** #include "usb_debug_only.h"
  29:usb_debug_only.c **** 
  30:usb_debug_only.c **** /**************************************************************************
  31:usb_debug_only.c ****  *
  32:usb_debug_only.c ****  *  Configurable Options
  33:usb_debug_only.c ****  *
  34:usb_debug_only.c ****  **************************************************************************/
  35:usb_debug_only.c **** 
  36:usb_debug_only.c **** // You can change these to give your code its own name.  On Windows,
  37:usb_debug_only.c **** // these are only used before an INF file (driver install) is loaded.
  38:usb_debug_only.c **** #define STR_MANUFACTURER	L"Your Name"
  39:usb_debug_only.c **** #define STR_PRODUCT		L"Your USB Device"
  40:usb_debug_only.c **** 
  41:usb_debug_only.c **** 
  42:usb_debug_only.c **** // Mac OS-X and Linux automatically load the correct drivers.  On
  43:usb_debug_only.c **** // Windows, even though the driver is supplied by Microsoft, an
  44:usb_debug_only.c **** // INF file is needed to load the driver.  These numbers need to
  45:usb_debug_only.c **** // match the INF file.
  46:usb_debug_only.c **** #define VENDOR_ID		0x16C0
  47:usb_debug_only.c **** #define PRODUCT_ID		0x0479
  48:usb_debug_only.c **** 
  49:usb_debug_only.c **** 
  50:usb_debug_only.c **** // USB devices are supposed to implment a halt feature, which is
  51:usb_debug_only.c **** // rarely (if ever) used.  If you comment this line out, the halt
  52:usb_debug_only.c **** // code will be removed, saving 102 bytes of space (gcc 4.3.0).
  53:usb_debug_only.c **** // This is not strictly USB compliant, but works with all major
  54:usb_debug_only.c **** // operating systems.
  55:usb_debug_only.c **** #define SUPPORT_ENDPOINT_HALT
  56:usb_debug_only.c **** 
  57:usb_debug_only.c **** 
  58:usb_debug_only.c **** 
  59:usb_debug_only.c **** /**************************************************************************
  60:usb_debug_only.c ****  *
  61:usb_debug_only.c ****  *  Endpoint Buffer Configuration
  62:usb_debug_only.c ****  *
  63:usb_debug_only.c ****  **************************************************************************/
  64:usb_debug_only.c **** 
  65:usb_debug_only.c **** // you might want to change the buffer size, up to 64 bytes.
  66:usb_debug_only.c **** // The host reserves your bandwidth because this is an interrupt
  67:usb_debug_only.c **** // endpoint, so it won't be available to other interrupt or isync
  68:usb_debug_only.c **** // endpoints in other devices on the bus.
  69:usb_debug_only.c **** 
  70:usb_debug_only.c **** #define ENDPOINT0_SIZE		32
  71:usb_debug_only.c **** #define DEBUG_TX_ENDPOINT	3
  72:usb_debug_only.c **** #define DEBUG_TX_SIZE		32
  73:usb_debug_only.c **** #define DEBUG_TX_BUFFER		EP_DOUBLE_BUFFER
  74:usb_debug_only.c **** 
  75:usb_debug_only.c **** static const uint8_t PROGMEM endpoint_config_table[] = {
  76:usb_debug_only.c **** 	0,
  77:usb_debug_only.c **** 	0,
  78:usb_debug_only.c **** 	1, EP_TYPE_INTERRUPT_IN,  EP_SIZE(DEBUG_TX_SIZE) | DEBUG_TX_BUFFER,
  79:usb_debug_only.c **** 	0
  80:usb_debug_only.c **** };
  81:usb_debug_only.c **** 
  82:usb_debug_only.c **** 
  83:usb_debug_only.c **** /**************************************************************************
  84:usb_debug_only.c ****  *
  85:usb_debug_only.c ****  *  Descriptor Data
  86:usb_debug_only.c ****  *
  87:usb_debug_only.c ****  **************************************************************************/
  88:usb_debug_only.c **** 
  89:usb_debug_only.c **** // Descriptors are the data that your computer reads when it auto-detects
  90:usb_debug_only.c **** // this USB device (called "enumeration" in USB lingo).  The most commonly
  91:usb_debug_only.c **** // changed items are editable at the top of this file.  Changing things
  92:usb_debug_only.c **** // in here should only be done by those who've read chapter 9 of the USB
  93:usb_debug_only.c **** // spec and relevant portions of any USB class specifications!
  94:usb_debug_only.c **** 
  95:usb_debug_only.c **** 
  96:usb_debug_only.c **** static const uint8_t PROGMEM device_descriptor[] = {
  97:usb_debug_only.c **** 	18,					// bLength
  98:usb_debug_only.c **** 	1,					// bDescriptorType
  99:usb_debug_only.c **** 	0x00, 0x02,				// bcdUSB
 100:usb_debug_only.c **** 	0,					// bDeviceClass
 101:usb_debug_only.c **** 	0,					// bDeviceSubClass
 102:usb_debug_only.c **** 	0,					// bDeviceProtocol
 103:usb_debug_only.c **** 	ENDPOINT0_SIZE,				// bMaxPacketSize0
 104:usb_debug_only.c **** 	LSB(VENDOR_ID), MSB(VENDOR_ID),		// idVendor
 105:usb_debug_only.c **** 	LSB(PRODUCT_ID), MSB(PRODUCT_ID),	// idProduct
 106:usb_debug_only.c **** 	0x00, 0x01,				// bcdDevice
 107:usb_debug_only.c **** 	1,					// iManufacturer
 108:usb_debug_only.c **** 	2,					// iProduct
 109:usb_debug_only.c **** 	0,					// iSerialNumber
 110:usb_debug_only.c **** 	1					// bNumConfigurations
 111:usb_debug_only.c **** };
 112:usb_debug_only.c **** 
 113:usb_debug_only.c **** static const uint8_t PROGMEM hid_report_descriptor[] = {
 114:usb_debug_only.c **** 	0x06, 0x31, 0xFF,			// Usage Page 0xFF31 (vendor defined)
 115:usb_debug_only.c **** 	0x09, 0x74,				// Usage 0x74
 116:usb_debug_only.c **** 	0xA1, 0x53,				// Collection 0x53
 117:usb_debug_only.c **** 	0x75, 0x08,				// report size = 8 bits
 118:usb_debug_only.c **** 	0x15, 0x00,				// logical minimum = 0
 119:usb_debug_only.c **** 	0x26, 0xFF, 0x00,			// logical maximum = 255
 120:usb_debug_only.c **** 	0x95, DEBUG_TX_SIZE,			// report count
 121:usb_debug_only.c **** 	0x09, 0x75,				// usage
 122:usb_debug_only.c **** 	0x81, 0x02,				// Input (array)
 123:usb_debug_only.c **** 	0xC0					// end collection
 124:usb_debug_only.c **** };
 125:usb_debug_only.c **** 
 126:usb_debug_only.c **** #define CONFIG1_DESC_SIZE (9+9+9+7)
 127:usb_debug_only.c **** #define HID_DESC2_OFFSET  (9+9)
 128:usb_debug_only.c **** static const uint8_t PROGMEM config1_descriptor[CONFIG1_DESC_SIZE] = {
 129:usb_debug_only.c **** 	// configuration descriptor, USB spec 9.6.3, page 264-266, Table 9-10
 130:usb_debug_only.c **** 	9, 					// bLength;
 131:usb_debug_only.c **** 	2,					// bDescriptorType;
 132:usb_debug_only.c **** 	LSB(CONFIG1_DESC_SIZE),			// wTotalLength
 133:usb_debug_only.c **** 	MSB(CONFIG1_DESC_SIZE),
 134:usb_debug_only.c **** 	1,					// bNumInterfaces
 135:usb_debug_only.c **** 	1,					// bConfigurationValue
 136:usb_debug_only.c **** 	0,					// iConfiguration
 137:usb_debug_only.c **** 	0xC0,					// bmAttributes
 138:usb_debug_only.c **** 	50,					// bMaxPower
 139:usb_debug_only.c **** 	// interface descriptor, USB spec 9.6.5, page 267-269, Table 9-12
 140:usb_debug_only.c **** 	9,					// bLength
 141:usb_debug_only.c **** 	4,					// bDescriptorType
 142:usb_debug_only.c **** 	0,					// bInterfaceNumber
 143:usb_debug_only.c **** 	0,					// bAlternateSetting
 144:usb_debug_only.c **** 	1,					// bNumEndpoints
 145:usb_debug_only.c **** 	0x03,					// bInterfaceClass (0x03 = HID)
 146:usb_debug_only.c **** 	0x00,					// bInterfaceSubClass
 147:usb_debug_only.c **** 	0x00,					// bInterfaceProtocol
 148:usb_debug_only.c **** 	0,					// iInterface
 149:usb_debug_only.c **** 	// HID interface descriptor, HID 1.11 spec, section 6.2.1
 150:usb_debug_only.c **** 	9,					// bLength
 151:usb_debug_only.c **** 	0x21,					// bDescriptorType
 152:usb_debug_only.c **** 	0x11, 0x01,				// bcdHID
 153:usb_debug_only.c **** 	0,					// bCountryCode
 154:usb_debug_only.c **** 	1,					// bNumDescriptors
 155:usb_debug_only.c **** 	0x22,					// bDescriptorType
 156:usb_debug_only.c **** 	sizeof(hid_report_descriptor),		// wDescriptorLength
 157:usb_debug_only.c **** 	0,
 158:usb_debug_only.c **** 	// endpoint descriptor, USB spec 9.6.6, page 269-271, Table 9-13
 159:usb_debug_only.c **** 	7,					// bLength
 160:usb_debug_only.c **** 	5,					// bDescriptorType
 161:usb_debug_only.c **** 	DEBUG_TX_ENDPOINT | 0x80,		// bEndpointAddress
 162:usb_debug_only.c **** 	0x03,					// bmAttributes (0x03=intr)
 163:usb_debug_only.c **** 	DEBUG_TX_SIZE, 0,			// wMaxPacketSize
 164:usb_debug_only.c **** 	1					// bInterval
 165:usb_debug_only.c **** };
 166:usb_debug_only.c **** 
 167:usb_debug_only.c **** // If you're desperate for a little extra code memory, these strings
 168:usb_debug_only.c **** // can be completely removed if iManufacturer, iProduct, iSerialNumber
 169:usb_debug_only.c **** // in the device desciptor are changed to zeros.
 170:usb_debug_only.c **** struct usb_string_descriptor_struct {
 171:usb_debug_only.c **** 	uint8_t bLength;
 172:usb_debug_only.c **** 	uint8_t bDescriptorType;
 173:usb_debug_only.c **** 	int16_t wString[];
 174:usb_debug_only.c **** };
 175:usb_debug_only.c **** static const struct usb_string_descriptor_struct PROGMEM string0 = {
 176:usb_debug_only.c **** 	4,
 177:usb_debug_only.c **** 	3,
 178:usb_debug_only.c **** 	{0x0409}
 179:usb_debug_only.c **** };
 180:usb_debug_only.c **** static const struct usb_string_descriptor_struct PROGMEM string1 = {
 181:usb_debug_only.c **** 	sizeof(STR_MANUFACTURER),
 182:usb_debug_only.c **** 	3,
 183:usb_debug_only.c **** 	STR_MANUFACTURER
 184:usb_debug_only.c **** };
 185:usb_debug_only.c **** static const struct usb_string_descriptor_struct PROGMEM string2 = {
 186:usb_debug_only.c **** 	sizeof(STR_PRODUCT),
 187:usb_debug_only.c **** 	3,
 188:usb_debug_only.c **** 	STR_PRODUCT
 189:usb_debug_only.c **** };
 190:usb_debug_only.c **** 
 191:usb_debug_only.c **** // This table defines which descriptor data is sent for each specific
 192:usb_debug_only.c **** // request from the host (in wValue and wIndex).
 193:usb_debug_only.c **** static const struct descriptor_list_struct {
 194:usb_debug_only.c **** 	uint16_t	wValue;
 195:usb_debug_only.c **** 	uint16_t	wIndex;
 196:usb_debug_only.c **** 	const uint8_t	*addr;
 197:usb_debug_only.c **** 	uint8_t		length;
 198:usb_debug_only.c **** } PROGMEM descriptor_list[] = {
 199:usb_debug_only.c **** 	{0x0100, 0x0000, device_descriptor, sizeof(device_descriptor)},
 200:usb_debug_only.c **** 	{0x0200, 0x0000, config1_descriptor, sizeof(config1_descriptor)},
 201:usb_debug_only.c **** 	{0x2200, 0x0000, hid_report_descriptor, sizeof(hid_report_descriptor)},
 202:usb_debug_only.c **** 	{0x2100, 0x0000, config1_descriptor+HID_DESC2_OFFSET, 9},
 203:usb_debug_only.c **** 	{0x0300, 0x0000, (const uint8_t *)&string0, 4},
 204:usb_debug_only.c **** 	{0x0301, 0x0409, (const uint8_t *)&string1, sizeof(STR_MANUFACTURER)},
 205:usb_debug_only.c **** 	{0x0302, 0x0409, (const uint8_t *)&string2, sizeof(STR_PRODUCT)}
 206:usb_debug_only.c **** };
 207:usb_debug_only.c **** #define NUM_DESC_LIST (sizeof(descriptor_list)/sizeof(struct descriptor_list_struct))
 208:usb_debug_only.c **** 
 209:usb_debug_only.c **** 
 210:usb_debug_only.c **** /**************************************************************************
 211:usb_debug_only.c ****  *
 212:usb_debug_only.c ****  *  Variables - these are the only non-stack RAM usage
 213:usb_debug_only.c ****  *
 214:usb_debug_only.c ****  **************************************************************************/
 215:usb_debug_only.c **** 
 216:usb_debug_only.c **** // zero when we are not configured, non-zero when enumerated
 217:usb_debug_only.c **** static volatile uint8_t usb_configuration=0;
 218:usb_debug_only.c **** 
 219:usb_debug_only.c **** // the time remaining before we transmit any partially full
 220:usb_debug_only.c **** // packet, or send a zero length packet.
 221:usb_debug_only.c **** static volatile uint8_t debug_flush_timer=0;
 222:usb_debug_only.c **** 
 223:usb_debug_only.c **** 
 224:usb_debug_only.c **** /**************************************************************************
 225:usb_debug_only.c ****  *
 226:usb_debug_only.c ****  *  Public Functions - these are the API intended for the user
 227:usb_debug_only.c ****  *
 228:usb_debug_only.c ****  **************************************************************************/
 229:usb_debug_only.c **** 
 230:usb_debug_only.c **** 
 231:usb_debug_only.c **** // initialize USB
 232:usb_debug_only.c **** void usb_init(void)
 233:usb_debug_only.c **** {
 234:usb_debug_only.c **** 	HW_CONFIG();
 235:usb_debug_only.c **** 	USB_FREEZE();				// enable USB
 236:usb_debug_only.c **** 	PLL_CONFIG();				// config PLL
 237:usb_debug_only.c ****         while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
 238:usb_debug_only.c ****         USB_CONFIG();				// start USB clock
 239:usb_debug_only.c ****         UDCON = 0;				// enable attach resistor
 240:usb_debug_only.c **** 	usb_configuration = 0;
 241:usb_debug_only.c ****         UDIEN = (1<<EORSTE)|(1<<SOFE);
 242:usb_debug_only.c **** 	sei();
 243:usb_debug_only.c **** }
 244:usb_debug_only.c **** 
 245:usb_debug_only.c **** // return 0 if the USB is not configured, or the configuration
 246:usb_debug_only.c **** // number selected by the HOST
 247:usb_debug_only.c **** uint8_t usb_configured(void)
 248:usb_debug_only.c **** {
 249:usb_debug_only.c **** 	return usb_configuration;
 250:usb_debug_only.c **** }
 251:usb_debug_only.c **** 
 252:usb_debug_only.c **** // transmit a character.  0 returned on success, -1 on error
 253:usb_debug_only.c **** int8_t usb_debug_putchar(uint8_t c)
 254:usb_debug_only.c **** {
 255:usb_debug_only.c **** 	static uint8_t previous_timeout=0;
 256:usb_debug_only.c **** 	uint8_t timeout, intr_state;
 257:usb_debug_only.c **** 
 258:usb_debug_only.c **** 	// if we're not online (enumerated and configured), error
 259:usb_debug_only.c **** 	if (!usb_configuration) return -1;
 260:usb_debug_only.c **** 	// interrupts are disabled so these functions can be
 261:usb_debug_only.c **** 	// used from the main program or interrupt context,
 262:usb_debug_only.c **** 	// even both in the same program!
 263:usb_debug_only.c **** 	intr_state = SREG;
 264:usb_debug_only.c **** 	cli();
 265:usb_debug_only.c **** 	UENUM = DEBUG_TX_ENDPOINT;
 266:usb_debug_only.c **** 	// if we gave up due to timeout before, don't wait again
 267:usb_debug_only.c **** 	if (previous_timeout) {
 268:usb_debug_only.c **** 		if (!(UEINTX & (1<<RWAL))) {
 269:usb_debug_only.c **** 			SREG = intr_state;
 270:usb_debug_only.c **** 			return -1;
 271:usb_debug_only.c **** 		}
 272:usb_debug_only.c **** 		previous_timeout = 0;
 273:usb_debug_only.c **** 	}
 274:usb_debug_only.c **** 	// wait for the FIFO to be ready to accept data
 275:usb_debug_only.c **** 	timeout = UDFNUML + 4;
 276:usb_debug_only.c **** 	while (1) {
 277:usb_debug_only.c **** 		// are we ready to transmit?
 278:usb_debug_only.c **** 		if (UEINTX & (1<<RWAL)) break;
 279:usb_debug_only.c **** 		SREG = intr_state;
 280:usb_debug_only.c **** 		// have we waited too long?
 281:usb_debug_only.c **** 		if (UDFNUML == timeout) {
 282:usb_debug_only.c **** 			previous_timeout = 1;
 283:usb_debug_only.c **** 			return -1;
 284:usb_debug_only.c **** 		}
 285:usb_debug_only.c **** 		// has the USB gone offline?
 286:usb_debug_only.c **** 		if (!usb_configuration) return -1;
 287:usb_debug_only.c **** 		// get ready to try checking again
 288:usb_debug_only.c **** 		intr_state = SREG;
 289:usb_debug_only.c **** 		cli();
 290:usb_debug_only.c **** 		UENUM = DEBUG_TX_ENDPOINT;
 291:usb_debug_only.c **** 	}
 292:usb_debug_only.c **** 	// actually write the byte into the FIFO
 293:usb_debug_only.c **** 	UEDATX = c;
 294:usb_debug_only.c **** 	// if this completed a packet, transmit it now!
 295:usb_debug_only.c **** 	if (!(UEINTX & (1<<RWAL))) {
 296:usb_debug_only.c **** 		UEINTX = 0x3A;
 297:usb_debug_only.c **** 		debug_flush_timer = 0;
 298:usb_debug_only.c **** 	} else {
 299:usb_debug_only.c **** 		debug_flush_timer = 2;
 300:usb_debug_only.c **** 	}
 301:usb_debug_only.c **** 	SREG = intr_state;
 302:usb_debug_only.c **** 	return 0;
 303:usb_debug_only.c **** }
 304:usb_debug_only.c **** 
 305:usb_debug_only.c **** 
 306:usb_debug_only.c **** // immediately transmit any buffered output.
 307:usb_debug_only.c **** void usb_debug_flush_output(void)
 308:usb_debug_only.c **** {
 309:usb_debug_only.c **** 	uint8_t intr_state;
 310:usb_debug_only.c **** 
 311:usb_debug_only.c **** 	intr_state = SREG;
 312:usb_debug_only.c **** 	cli();
 313:usb_debug_only.c **** 	if (debug_flush_timer) {
 314:usb_debug_only.c **** 		UENUM = DEBUG_TX_ENDPOINT;
 315:usb_debug_only.c **** 		while ((UEINTX & (1<<RWAL))) {
 316:usb_debug_only.c **** 			UEDATX = 0;
 317:usb_debug_only.c **** 		}
 318:usb_debug_only.c **** 		UEINTX = 0x3A;
 319:usb_debug_only.c **** 		debug_flush_timer = 0;
 320:usb_debug_only.c **** 	}
 321:usb_debug_only.c **** 	SREG = intr_state;
 322:usb_debug_only.c **** }
 323:usb_debug_only.c **** 
 324:usb_debug_only.c **** 
 325:usb_debug_only.c **** 
 326:usb_debug_only.c **** /**************************************************************************
 327:usb_debug_only.c ****  *
 328:usb_debug_only.c ****  *  Private Functions - not intended for general user consumption....
 329:usb_debug_only.c ****  *
 330:usb_debug_only.c ****  **************************************************************************/
 331:usb_debug_only.c **** 
 332:usb_debug_only.c **** 
 333:usb_debug_only.c **** 
 334:usb_debug_only.c **** // USB Device Interrupt - handle all device-level events
 335:usb_debug_only.c **** // the transmit buffer flushing is triggered by the start of frame
 336:usb_debug_only.c **** //
 337:usb_debug_only.c **** ISR(USB_GEN_vect)
 338:usb_debug_only.c **** {
 339:usb_debug_only.c **** 	uint8_t intbits, t;
 340:usb_debug_only.c **** 
 341:usb_debug_only.c ****         intbits = UDINT;
 342:usb_debug_only.c ****         UDINT = 0;
 343:usb_debug_only.c ****         if (intbits & (1<<EORSTI)) {
 344:usb_debug_only.c **** 		UENUM = 0;
 345:usb_debug_only.c **** 		UECONX = 1;
 346:usb_debug_only.c **** 		UECFG0X = EP_TYPE_CONTROL;
 347:usb_debug_only.c **** 		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 348:usb_debug_only.c **** 		UEIENX = (1<<RXSTPE);
 349:usb_debug_only.c **** 		usb_configuration = 0;
 350:usb_debug_only.c ****         }
 351:usb_debug_only.c **** 	if (intbits & (1<<SOFI)) {
 352:usb_debug_only.c **** 		if (usb_configuration) {
 353:usb_debug_only.c **** 			t = debug_flush_timer;
 354:usb_debug_only.c **** 			if (t) {
 355:usb_debug_only.c **** 				debug_flush_timer = -- t;
 356:usb_debug_only.c **** 				if (!t) {
 357:usb_debug_only.c **** 					UENUM = DEBUG_TX_ENDPOINT;
 358:usb_debug_only.c **** 					while ((UEINTX & (1<<RWAL))) {
 359:usb_debug_only.c **** 						UEDATX = 0;
 360:usb_debug_only.c **** 					}
 361:usb_debug_only.c **** 					UEINTX = 0x3A;
 362:usb_debug_only.c **** 				}
 363:usb_debug_only.c **** 			}
 364:usb_debug_only.c **** 		}
 365:usb_debug_only.c **** 	}
 366:usb_debug_only.c **** }
 367:usb_debug_only.c **** 
 368:usb_debug_only.c **** 
 369:usb_debug_only.c **** // Misc functions to wait for ready and send/receive packets
 370:usb_debug_only.c **** static inline void usb_wait_in_ready(void)
 371:usb_debug_only.c **** {
  16               		.loc 1 371 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.L3:
 372:usb_debug_only.c **** 	while (!(UEINTX & (1<<TXINI))) ;
  23               		.loc 1 372 0 discriminator 1
  24 0000 8091 E800 		lds r24,232
  25 0004 80FF      		sbrs r24,0
  26 0006 00C0      		rjmp .L3
  27               	/* epilogue start */
 373:usb_debug_only.c **** }
  28               		.loc 1 373 0
  29 0008 0895      		ret
  30               		.cfi_endproc
  31               	.LFE6:
  33               		.section	.text.usb_init,"ax",@progbits
  34               	.global	usb_init
  36               	usb_init:
  37               	.LFB1:
 233:usb_debug_only.c **** {
  38               		.loc 1 233 0
  39               		.cfi_startproc
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
 234:usb_debug_only.c **** 	HW_CONFIG();
  44               		.loc 1 234 0
  45 0000 81E8      		ldi r24,lo8(-127)
  46 0002 8093 D700 		sts 215,r24
 235:usb_debug_only.c **** 	USB_FREEZE();				// enable USB
  47               		.loc 1 235 0
  48 0006 80EA      		ldi r24,lo8(-96)
  49 0008 8093 D800 		sts 216,r24
 236:usb_debug_only.c **** 	PLL_CONFIG();				// config PLL
  50               		.loc 1 236 0
  51 000c 86E1      		ldi r24,lo8(22)
  52 000e 89BD      		out 0x29,r24
  53               	.L7:
 237:usb_debug_only.c ****         while (!(PLLCSR & (1<<PLOCK))) ;	// wait for PLL lock
  54               		.loc 1 237 0 discriminator 1
  55 0010 09B4      		in __tmp_reg__,0x29
  56 0012 00FE      		sbrs __tmp_reg__,0
  57 0014 00C0      		rjmp .L7
 238:usb_debug_only.c ****         USB_CONFIG();				// start USB clock
  58               		.loc 1 238 0
  59 0016 80E9      		ldi r24,lo8(-112)
  60 0018 8093 D800 		sts 216,r24
 239:usb_debug_only.c ****         UDCON = 0;				// enable attach resistor
  61               		.loc 1 239 0
  62 001c 1092 E000 		sts 224,__zero_reg__
 240:usb_debug_only.c **** 	usb_configuration = 0;
  63               		.loc 1 240 0
  64 0020 1092 0000 		sts usb_configuration,__zero_reg__
 241:usb_debug_only.c ****         UDIEN = (1<<EORSTE)|(1<<SOFE);
  65               		.loc 1 241 0
  66 0024 8CE0      		ldi r24,lo8(12)
  67 0026 8093 E200 		sts 226,r24
 242:usb_debug_only.c **** 	sei();
  68               		.loc 1 242 0
  69               	/* #APP */
  70               	 ;  242 "usb_debug_only.c" 1
  71 002a 7894      		sei
  72               	 ;  0 "" 2
  73               	/* #NOAPP */
  74 002c 0895      		ret
  75               		.cfi_endproc
  76               	.LFE1:
  78               		.section	.text.usb_configured,"ax",@progbits
  79               	.global	usb_configured
  81               	usb_configured:
  82               	.LFB2:
 248:usb_debug_only.c **** {
  83               		.loc 1 248 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 249:usb_debug_only.c **** 	return usb_configuration;
  89               		.loc 1 249 0
  90 0000 8091 0000 		lds r24,usb_configuration
 250:usb_debug_only.c **** }
  91               		.loc 1 250 0
  92 0004 0895      		ret
  93               		.cfi_endproc
  94               	.LFE2:
  96               		.section	.text.usb_debug_putchar,"ax",@progbits
  97               	.global	usb_debug_putchar
  99               	usb_debug_putchar:
 100               	.LFB3:
 254:usb_debug_only.c **** {
 101               		.loc 1 254 0
 102               		.cfi_startproc
 103               	.LVL0:
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
 259:usb_debug_only.c **** 	if (!usb_configuration) return -1;
 108               		.loc 1 259 0
 109 0000 9091 0000 		lds r25,usb_configuration
 110 0004 9923      		tst r25
 111 0006 01F0      		breq .L26
 263:usb_debug_only.c **** 	intr_state = SREG;
 112               		.loc 1 263 0
 113 0008 9FB7      		in r25,__SREG__
 114               	.LVL1:
 264:usb_debug_only.c **** 	cli();
 115               		.loc 1 264 0
 116               	/* #APP */
 117               	 ;  264 "usb_debug_only.c" 1
 118 000a F894      		cli
 119               	 ;  0 "" 2
 265:usb_debug_only.c **** 	UENUM = DEBUG_TX_ENDPOINT;
 120               		.loc 1 265 0
 121               	/* #NOAPP */
 122 000c 23E0      		ldi r18,lo8(3)
 123 000e 2093 E900 		sts 233,r18
 267:usb_debug_only.c **** 	if (previous_timeout) {
 124               		.loc 1 267 0
 125 0012 2091 0000 		lds r18,previous_timeout.1662
 126 0016 2223      		tst r18
 127 0018 01F0      		breq .L12
 268:usb_debug_only.c **** 		if (!(UEINTX & (1<<RWAL))) {
 128               		.loc 1 268 0
 129 001a 2091 E800 		lds r18,232
 130 001e 25FD      		sbrc r18,5
 131 0020 00C0      		rjmp .L13
 269:usb_debug_only.c **** 			SREG = intr_state;
 132               		.loc 1 269 0
 133 0022 9FBF      		out __SREG__,r25
 134               	.LVL2:
 135               	.L26:
 270:usb_debug_only.c **** 			return -1;
 136               		.loc 1 270 0
 137 0024 8FEF      		ldi r24,lo8(-1)
 138 0026 0895      		ret
 139               	.LVL3:
 140               	.L13:
 272:usb_debug_only.c **** 		previous_timeout = 0;
 141               		.loc 1 272 0
 142 0028 1092 0000 		sts previous_timeout.1662,__zero_reg__
 143               	.L12:
 275:usb_debug_only.c **** 	timeout = UDFNUML + 4;
 144               		.loc 1 275 0
 145 002c 2091 E400 		lds r18,228
 146 0030 2C5F      		subi r18,lo8(-(4))
 147               	.LVL4:
 290:usb_debug_only.c **** 		UENUM = DEBUG_TX_ENDPOINT;
 148               		.loc 1 290 0
 149 0032 33E0      		ldi r19,lo8(3)
 150               	.L17:
 278:usb_debug_only.c **** 		if (UEINTX & (1<<RWAL)) break;
 151               		.loc 1 278 0
 152 0034 4091 E800 		lds r20,232
 153 0038 45FD      		sbrc r20,5
 154 003a 00C0      		rjmp .L14
 279:usb_debug_only.c **** 		SREG = intr_state;
 155               		.loc 1 279 0
 156 003c 9FBF      		out __SREG__,r25
 281:usb_debug_only.c **** 		if (UDFNUML == timeout) {
 157               		.loc 1 281 0
 158 003e 9091 E400 		lds r25,228
 159               	.LVL5:
 160 0042 9213      		cpse r25,r18
 161 0044 00C0      		rjmp .L15
 282:usb_debug_only.c **** 			previous_timeout = 1;
 162               		.loc 1 282 0
 163 0046 81E0      		ldi r24,lo8(1)
 164               	.LVL6:
 165 0048 8093 0000 		sts previous_timeout.1662,r24
 166               	.LVL7:
 167 004c 00C0      		rjmp .L26
 168               	.LVL8:
 169               	.L15:
 286:usb_debug_only.c **** 		if (!usb_configuration) return -1;
 170               		.loc 1 286 0
 171 004e 9091 0000 		lds r25,usb_configuration
 172 0052 9923      		tst r25
 173 0054 01F0      		breq .L26
 288:usb_debug_only.c **** 		intr_state = SREG;
 174               		.loc 1 288 0
 175 0056 9FB7      		in r25,__SREG__
 176               	.LVL9:
 289:usb_debug_only.c **** 		cli();
 177               		.loc 1 289 0
 178               	/* #APP */
 179               	 ;  289 "usb_debug_only.c" 1
 180 0058 F894      		cli
 181               	 ;  0 "" 2
 290:usb_debug_only.c **** 		UENUM = DEBUG_TX_ENDPOINT;
 182               		.loc 1 290 0
 183               	/* #NOAPP */
 184 005a 3093 E900 		sts 233,r19
 291:usb_debug_only.c **** 	}
 185               		.loc 1 291 0
 186 005e 00C0      		rjmp .L17
 187               	.L14:
 293:usb_debug_only.c **** 	UEDATX = c;
 188               		.loc 1 293 0
 189 0060 8093 F100 		sts 241,r24
 295:usb_debug_only.c **** 	if (!(UEINTX & (1<<RWAL))) {
 190               		.loc 1 295 0
 191 0064 8091 E800 		lds r24,232
 192               	.LVL10:
 193 0068 85FD      		sbrc r24,5
 194 006a 00C0      		rjmp .L18
 296:usb_debug_only.c **** 		UEINTX = 0x3A;
 195               		.loc 1 296 0
 196 006c 8AE3      		ldi r24,lo8(58)
 197 006e 8093 E800 		sts 232,r24
 198               	.LVL11:
 297:usb_debug_only.c **** 		debug_flush_timer = 0;
 199               		.loc 1 297 0
 200 0072 1092 0000 		sts debug_flush_timer,__zero_reg__
 201 0076 00C0      		rjmp .L19
 202               	.LVL12:
 203               	.L18:
 299:usb_debug_only.c **** 		debug_flush_timer = 2;
 204               		.loc 1 299 0
 205 0078 82E0      		ldi r24,lo8(2)
 206 007a 8093 0000 		sts debug_flush_timer,r24
 207               	.LVL13:
 208               	.L19:
 301:usb_debug_only.c **** 	SREG = intr_state;
 209               		.loc 1 301 0
 210 007e 9FBF      		out __SREG__,r25
 302:usb_debug_only.c **** 	return 0;
 211               		.loc 1 302 0
 212 0080 80E0      		ldi r24,0
 303:usb_debug_only.c **** }
 213               		.loc 1 303 0
 214 0082 0895      		ret
 215               		.cfi_endproc
 216               	.LFE3:
 218               		.section	.text.usb_debug_flush_output,"ax",@progbits
 219               	.global	usb_debug_flush_output
 221               	usb_debug_flush_output:
 222               	.LFB4:
 308:usb_debug_only.c **** {
 223               		.loc 1 308 0
 224               		.cfi_startproc
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 0 */
 228               	.L__stack_usage = 0
 311:usb_debug_only.c **** 	intr_state = SREG;
 229               		.loc 1 311 0
 230 0000 8FB7      		in r24,__SREG__
 231               	.LVL14:
 312:usb_debug_only.c **** 	cli();
 232               		.loc 1 312 0
 233               	/* #APP */
 234               	 ;  312 "usb_debug_only.c" 1
 235 0002 F894      		cli
 236               	 ;  0 "" 2
 313:usb_debug_only.c **** 	if (debug_flush_timer) {
 237               		.loc 1 313 0
 238               	/* #NOAPP */
 239 0004 9091 0000 		lds r25,debug_flush_timer
 240 0008 9923      		tst r25
 241 000a 01F0      		breq .L28
 314:usb_debug_only.c **** 		UENUM = DEBUG_TX_ENDPOINT;
 242               		.loc 1 314 0
 243 000c 93E0      		ldi r25,lo8(3)
 244 000e 9093 E900 		sts 233,r25
 245               	.L29:
 315:usb_debug_only.c **** 		while ((UEINTX & (1<<RWAL))) {
 246               		.loc 1 315 0 discriminator 1
 247 0012 9091 E800 		lds r25,232
 248 0016 95FF      		sbrs r25,5
 249 0018 00C0      		rjmp .L34
 316:usb_debug_only.c **** 			UEDATX = 0;
 250               		.loc 1 316 0
 251 001a 1092 F100 		sts 241,__zero_reg__
 252 001e 00C0      		rjmp .L29
 253               	.L34:
 318:usb_debug_only.c **** 		UEINTX = 0x3A;
 254               		.loc 1 318 0
 255 0020 9AE3      		ldi r25,lo8(58)
 256 0022 9093 E800 		sts 232,r25
 319:usb_debug_only.c **** 		debug_flush_timer = 0;
 257               		.loc 1 319 0
 258 0026 1092 0000 		sts debug_flush_timer,__zero_reg__
 259               	.L28:
 321:usb_debug_only.c **** 	SREG = intr_state;
 260               		.loc 1 321 0
 261 002a 8FBF      		out __SREG__,r24
 262 002c 0895      		ret
 263               		.cfi_endproc
 264               	.LFE4:
 266               		.section	.text.__vector_10,"ax",@progbits
 267               	.global	__vector_10
 269               	__vector_10:
 270               	.LFB5:
 338:usb_debug_only.c **** {
 271               		.loc 1 338 0
 272               		.cfi_startproc
 273 0000 1F92      		push r1
 274               	.LCFI0:
 275               		.cfi_def_cfa_offset 3
 276               		.cfi_offset 1, -2
 277 0002 0F92      		push r0
 278               	.LCFI1:
 279               		.cfi_def_cfa_offset 4
 280               		.cfi_offset 0, -3
 281 0004 0FB6      		in r0,__SREG__
 282 0006 0F92      		push r0
 283 0008 1124      		clr __zero_reg__
 284 000a 8F93      		push r24
 285               	.LCFI2:
 286               		.cfi_def_cfa_offset 5
 287               		.cfi_offset 24, -4
 288 000c 9F93      		push r25
 289               	.LCFI3:
 290               		.cfi_def_cfa_offset 6
 291               		.cfi_offset 25, -5
 292               	/* prologue: Signal */
 293               	/* frame size = 0 */
 294               	/* stack size = 5 */
 295               	.L__stack_usage = 5
 341:usb_debug_only.c ****         intbits = UDINT;
 296               		.loc 1 341 0
 297 000e 8091 E100 		lds r24,225
 298               	.LVL15:
 342:usb_debug_only.c ****         UDINT = 0;
 299               		.loc 1 342 0
 300 0012 1092 E100 		sts 225,__zero_reg__
 343:usb_debug_only.c ****         if (intbits & (1<<EORSTI)) {
 301               		.loc 1 343 0
 302 0016 83FF      		sbrs r24,3
 303 0018 00C0      		rjmp .L36
 344:usb_debug_only.c **** 		UENUM = 0;
 304               		.loc 1 344 0
 305 001a 1092 E900 		sts 233,__zero_reg__
 345:usb_debug_only.c **** 		UECONX = 1;
 306               		.loc 1 345 0
 307 001e 91E0      		ldi r25,lo8(1)
 308 0020 9093 EB00 		sts 235,r25
 346:usb_debug_only.c **** 		UECFG0X = EP_TYPE_CONTROL;
 309               		.loc 1 346 0
 310 0024 1092 EC00 		sts 236,__zero_reg__
 347:usb_debug_only.c **** 		UECFG1X = EP_SIZE(ENDPOINT0_SIZE) | EP_SINGLE_BUFFER;
 311               		.loc 1 347 0
 312 0028 92E2      		ldi r25,lo8(34)
 313 002a 9093 ED00 		sts 237,r25
 348:usb_debug_only.c **** 		UEIENX = (1<<RXSTPE);
 314               		.loc 1 348 0
 315 002e 98E0      		ldi r25,lo8(8)
 316 0030 9093 F000 		sts 240,r25
 349:usb_debug_only.c **** 		usb_configuration = 0;
 317               		.loc 1 349 0
 318 0034 1092 0000 		sts usb_configuration,__zero_reg__
 319               	.L36:
 351:usb_debug_only.c **** 	if (intbits & (1<<SOFI)) {
 320               		.loc 1 351 0
 321 0038 82FF      		sbrs r24,2
 322 003a 00C0      		rjmp .L35
 352:usb_debug_only.c **** 		if (usb_configuration) {
 323               		.loc 1 352 0
 324 003c 8091 0000 		lds r24,usb_configuration
 325               	.LVL16:
 326 0040 8823      		tst r24
 327 0042 01F0      		breq .L35
 353:usb_debug_only.c **** 			t = debug_flush_timer;
 328               		.loc 1 353 0
 329 0044 8091 0000 		lds r24,debug_flush_timer
 330               	.LVL17:
 354:usb_debug_only.c **** 			if (t) {
 331               		.loc 1 354 0
 332 0048 8823      		tst r24
 333 004a 01F0      		breq .L35
 355:usb_debug_only.c **** 				debug_flush_timer = -- t;
 334               		.loc 1 355 0
 335 004c 8150      		subi r24,lo8(-(-1))
 336               	.LVL18:
 337 004e 8093 0000 		sts debug_flush_timer,r24
 356:usb_debug_only.c **** 				if (!t) {
 338               		.loc 1 356 0
 339 0052 8111      		cpse r24,__zero_reg__
 340 0054 00C0      		rjmp .L35
 357:usb_debug_only.c **** 					UENUM = DEBUG_TX_ENDPOINT;
 341               		.loc 1 357 0
 342 0056 83E0      		ldi r24,lo8(3)
 343               	.LVL19:
 344 0058 8093 E900 		sts 233,r24
 345               	.LVL20:
 346               	.L40:
 358:usb_debug_only.c **** 					while ((UEINTX & (1<<RWAL))) {
 347               		.loc 1 358 0 discriminator 1
 348 005c 8091 E800 		lds r24,232
 349 0060 85FF      		sbrs r24,5
 350 0062 00C0      		rjmp .L51
 359:usb_debug_only.c **** 						UEDATX = 0;
 351               		.loc 1 359 0
 352 0064 1092 F100 		sts 241,__zero_reg__
 353 0068 00C0      		rjmp .L40
 354               	.L51:
 361:usb_debug_only.c **** 					UEINTX = 0x3A;
 355               		.loc 1 361 0
 356 006a 8AE3      		ldi r24,lo8(58)
 357 006c 8093 E800 		sts 232,r24
 358               	.L35:
 359               	/* epilogue start */
 366:usb_debug_only.c **** }
 360               		.loc 1 366 0
 361 0070 9F91      		pop r25
 362 0072 8F91      		pop r24
 363 0074 0F90      		pop r0
 364 0076 0FBE      		out __SREG__,r0
 365 0078 0F90      		pop r0
 366 007a 1F90      		pop r1
 367 007c 1895      		reti
 368               		.cfi_endproc
 369               	.LFE5:
 371               		.section	.text.__vector_11,"ax",@progbits
 372               	.global	__vector_11
 374               	__vector_11:
 375               	.LFB10:
 374:usb_debug_only.c **** static inline void usb_send_in(void)
 375:usb_debug_only.c **** {
 376:usb_debug_only.c **** 	UEINTX = ~(1<<TXINI);
 377:usb_debug_only.c **** }
 378:usb_debug_only.c **** static inline void usb_wait_receive_out(void)
 379:usb_debug_only.c **** {
 380:usb_debug_only.c **** 	while (!(UEINTX & (1<<RXOUTI))) ;
 381:usb_debug_only.c **** }
 382:usb_debug_only.c **** static inline void usb_ack_out(void)
 383:usb_debug_only.c **** {
 384:usb_debug_only.c **** 	UEINTX = ~(1<<RXOUTI);
 385:usb_debug_only.c **** }
 386:usb_debug_only.c **** 
 387:usb_debug_only.c **** 
 388:usb_debug_only.c **** 
 389:usb_debug_only.c **** // USB Endpoint Interrupt - endpoint 0 is handled here.  The
 390:usb_debug_only.c **** // other endpoints are manipulated by the user-callable
 391:usb_debug_only.c **** // functions, and the start-of-frame interrupt.
 392:usb_debug_only.c **** //
 393:usb_debug_only.c **** ISR(USB_COM_vect)
 394:usb_debug_only.c **** {
 376               		.loc 1 394 0
 377               		.cfi_startproc
 378 0000 1F92      		push r1
 379               	.LCFI4:
 380               		.cfi_def_cfa_offset 3
 381               		.cfi_offset 1, -2
 382 0002 0F92      		push r0
 383               	.LCFI5:
 384               		.cfi_def_cfa_offset 4
 385               		.cfi_offset 0, -3
 386 0004 0FB6      		in r0,__SREG__
 387 0006 0F92      		push r0
 388 0008 1124      		clr __zero_reg__
 389 000a 0BB6      		in r0,__RAMPZ__
 390 000c 0F92      		push r0
 391 000e EF92      		push r14
 392               	.LCFI6:
 393               		.cfi_def_cfa_offset 5
 394               		.cfi_offset 14, -4
 395 0010 FF92      		push r15
 396               	.LCFI7:
 397               		.cfi_def_cfa_offset 6
 398               		.cfi_offset 15, -5
 399 0012 0F93      		push r16
 400               	.LCFI8:
 401               		.cfi_def_cfa_offset 7
 402               		.cfi_offset 16, -6
 403 0014 1F93      		push r17
 404               	.LCFI9:
 405               		.cfi_def_cfa_offset 8
 406               		.cfi_offset 17, -7
 407 0016 2F93      		push r18
 408               	.LCFI10:
 409               		.cfi_def_cfa_offset 9
 410               		.cfi_offset 18, -8
 411 0018 3F93      		push r19
 412               	.LCFI11:
 413               		.cfi_def_cfa_offset 10
 414               		.cfi_offset 19, -9
 415 001a 4F93      		push r20
 416               	.LCFI12:
 417               		.cfi_def_cfa_offset 11
 418               		.cfi_offset 20, -10
 419 001c 5F93      		push r21
 420               	.LCFI13:
 421               		.cfi_def_cfa_offset 12
 422               		.cfi_offset 21, -11
 423 001e 6F93      		push r22
 424               	.LCFI14:
 425               		.cfi_def_cfa_offset 13
 426               		.cfi_offset 22, -12
 427 0020 7F93      		push r23
 428               	.LCFI15:
 429               		.cfi_def_cfa_offset 14
 430               		.cfi_offset 23, -13
 431 0022 8F93      		push r24
 432               	.LCFI16:
 433               		.cfi_def_cfa_offset 15
 434               		.cfi_offset 24, -14
 435 0024 9F93      		push r25
 436               	.LCFI17:
 437               		.cfi_def_cfa_offset 16
 438               		.cfi_offset 25, -15
 439 0026 AF93      		push r26
 440               	.LCFI18:
 441               		.cfi_def_cfa_offset 17
 442               		.cfi_offset 26, -16
 443 0028 BF93      		push r27
 444               	.LCFI19:
 445               		.cfi_def_cfa_offset 18
 446               		.cfi_offset 27, -17
 447 002a EF93      		push r30
 448               	.LCFI20:
 449               		.cfi_def_cfa_offset 19
 450               		.cfi_offset 30, -18
 451 002c FF93      		push r31
 452               	.LCFI21:
 453               		.cfi_def_cfa_offset 20
 454               		.cfi_offset 31, -19
 455 002e CF93      		push r28
 456               	.LCFI22:
 457               		.cfi_def_cfa_offset 21
 458               		.cfi_offset 28, -20
 459 0030 DF93      		push r29
 460               	.LCFI23:
 461               		.cfi_def_cfa_offset 22
 462               		.cfi_offset 29, -21
 463 0032 1F92      		push __zero_reg__
 464               	.LCFI24:
 465               		.cfi_def_cfa_offset 23
 466 0034 CDB7      		in r28,__SP_L__
 467 0036 DEB7      		in r29,__SP_H__
 468               	.LCFI25:
 469               		.cfi_def_cfa_register 28
 470               	/* prologue: Signal */
 471               	/* frame size = 1 */
 472               	/* stack size = 23 */
 473               	.L__stack_usage = 23
 395:usb_debug_only.c ****         uint8_t intbits;
 396:usb_debug_only.c **** 	const uint8_t *list;
 397:usb_debug_only.c ****         const uint8_t *cfg;
 398:usb_debug_only.c **** 	uint8_t i, n, len, en;
 399:usb_debug_only.c **** 	uint8_t bmRequestType;
 400:usb_debug_only.c **** 	uint8_t bRequest;
 401:usb_debug_only.c **** 	uint16_t wValue;
 402:usb_debug_only.c **** 	uint16_t wIndex;
 403:usb_debug_only.c **** 	uint16_t wLength;
 404:usb_debug_only.c **** 	uint16_t desc_val;
 405:usb_debug_only.c **** 	const uint8_t *desc_addr;
 406:usb_debug_only.c **** 	uint8_t	desc_length;
 407:usb_debug_only.c **** 
 408:usb_debug_only.c ****         UENUM = 0;
 474               		.loc 1 408 0
 475 0038 1092 E900 		sts 233,__zero_reg__
 409:usb_debug_only.c ****         intbits = UEINTX;
 476               		.loc 1 409 0
 477 003c 8091 E800 		lds r24,232
 478               	.LVL21:
 410:usb_debug_only.c ****         if (intbits & (1<<RXSTPI)) {
 479               		.loc 1 410 0
 480 0040 83FF      		sbrs r24,3
 481 0042 00C0      		rjmp .L53
 411:usb_debug_only.c ****                 bmRequestType = UEDATX;
 482               		.loc 1 411 0
 483 0044 9091 F100 		lds r25,241
 484               	.LVL22:
 412:usb_debug_only.c ****                 bRequest = UEDATX;
 485               		.loc 1 412 0
 486 0048 8091 F100 		lds r24,241
 487               	.LVL23:
 413:usb_debug_only.c ****                 wValue = UEDATX;
 488               		.loc 1 413 0
 489 004c 0091 F100 		lds r16,241
 490               	.LVL24:
 414:usb_debug_only.c ****                 wValue |= (UEDATX << 8);
 491               		.loc 1 414 0
 492 0050 2091 F100 		lds r18,241
 493 0054 10E0      		ldi r17,0
 494 0056 122B      		or r17,r18
 495               	.LVL25:
 415:usb_debug_only.c ****                 wIndex = UEDATX;
 496               		.loc 1 415 0
 497 0058 3091 F100 		lds r19,241
 498               	.LVL26:
 416:usb_debug_only.c ****                 wIndex |= (UEDATX << 8);
 499               		.loc 1 416 0
 500 005c 2091 F100 		lds r18,241
 501 0060 E32E      		mov r14,r19
 502 0062 F12C      		mov r15,__zero_reg__
 503 0064 F22A      		or r15,r18
 504               	.LVL27:
 417:usb_debug_only.c ****                 wLength = UEDATX;
 505               		.loc 1 417 0
 506 0066 2091 F100 		lds r18,241
 507               	.LVL28:
 418:usb_debug_only.c ****                 wLength |= (UEDATX << 8);
 508               		.loc 1 418 0
 509 006a 4091 F100 		lds r20,241
 510 006e 30E0      		ldi r19,0
 511 0070 342B      		or r19,r20
 512               	.LVL29:
 419:usb_debug_only.c ****                 UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
 513               		.loc 1 419 0
 514 0072 42EF      		ldi r20,lo8(-14)
 515               	.LVL30:
 516 0074 4093 E800 		sts 232,r20
 420:usb_debug_only.c ****                 if (bRequest == GET_DESCRIPTOR) {
 517               		.loc 1 420 0
 518 0078 8630      		cpi r24,lo8(6)
 519 007a 01F0      		breq .+2
 520 007c 00C0      		rjmp .L103
 521 007e 67E0      		ldi r22,lo8(7)
 522 0080 80E0      		ldi r24,lo8(descriptor_list)
 523 0082 90E0      		ldi r25,hi8(descriptor_list)
 524               	.LVL31:
 525               	.L64:
 526               	.LBB24:
 421:usb_debug_only.c **** 			list = (const uint8_t *)descriptor_list;
 422:usb_debug_only.c **** 			for (i=0; ; i++) {
 423:usb_debug_only.c **** 				if (i >= NUM_DESC_LIST) {
 424:usb_debug_only.c **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);  //stall
 425:usb_debug_only.c **** 					return;
 426:usb_debug_only.c **** 				}
 427:usb_debug_only.c **** 				desc_val = pgm_read_word(list);
 527               		.loc 1 427 0
 528 0084 FC01      		movw r30,r24
 529               	/* #APP */
 530               	 ;  427 "usb_debug_only.c" 1
 531 0086 4591      		lpm r20, Z+
 532 0088 5491      		lpm r21, Z
 533               		
 534               	 ;  0 "" 2
 535               	.LVL32:
 536               	/* #NOAPP */
 537               	.LBE24:
 428:usb_debug_only.c **** 				if (desc_val != wValue) {
 538               		.loc 1 428 0
 539 008a 4017      		cp r20,r16
 540 008c 5107      		cpc r21,r17
 541 008e 01F4      		brne .L104
 542               	.LVL33:
 429:usb_debug_only.c **** 					list += sizeof(struct descriptor_list_struct);
 430:usb_debug_only.c **** 					continue;
 431:usb_debug_only.c **** 				}
 432:usb_debug_only.c **** 				list += 2;
 543               		.loc 1 432 0
 544 0090 FC01      		movw r30,r24
 545 0092 3296      		adiw r30,2
 546               	.LVL34:
 547               	.LBB25:
 433:usb_debug_only.c **** 				desc_val = pgm_read_word(list);
 548               		.loc 1 433 0
 549               	/* #APP */
 550               	 ;  433 "usb_debug_only.c" 1
 551 0094 4591      		lpm r20, Z+
 552 0096 5491      		lpm r21, Z
 553               		
 554               	 ;  0 "" 2
 555               	.LVL35:
 556               	/* #NOAPP */
 557               	.LBE25:
 434:usb_debug_only.c **** 				if (desc_val != wIndex) {
 558               		.loc 1 434 0
 559 0098 4E15      		cp r20,r14
 560 009a 5F05      		cpc r21,r15
 561 009c 01F0      		breq .L59
 562               	.LVL36:
 563               	.L104:
 435:usb_debug_only.c **** 					list += sizeof(struct descriptor_list_struct)-2;
 564               		.loc 1 435 0
 565 009e 0796      		adiw r24,7
 566               	.LVL37:
 567 00a0 6150      		subi r22,lo8(-(-1))
 568               	.LVL38:
 423:usb_debug_only.c **** 				if (i >= NUM_DESC_LIST) {
 569               		.loc 1 423 0
 570 00a2 01F4      		brne .L64
 571 00a4 00C0      		rjmp .L53
 572               	.LVL39:
 573               	.L59:
 436:usb_debug_only.c **** 					continue;
 437:usb_debug_only.c **** 				}
 438:usb_debug_only.c **** 				list += 2;
 574               		.loc 1 438 0
 575 00a6 FC01      		movw r30,r24
 576 00a8 3496      		adiw r30,4
 577               	.LVL40:
 439:usb_debug_only.c **** 				desc_addr = (const uint8_t *)pgm_read_word(list);
 578               		.loc 1 439 0
 579               	/* #APP */
 580               	 ;  439 "usb_debug_only.c" 1
 581 00aa 4591      		lpm r20, Z+
 582 00ac 5491      		lpm r21, Z
 583               		
 584               	 ;  0 "" 2
 585               	.LVL41:
 440:usb_debug_only.c **** 				list += 2;
 586               		.loc 1 440 0
 587               	/* #NOAPP */
 588 00ae FC01      		movw r30,r24
 589 00b0 3696      		adiw r30,6
 590               	.LVL42:
 591               	.LBB26:
 441:usb_debug_only.c **** 				desc_length = pgm_read_byte(list);
 592               		.loc 1 441 0
 593               	/* #APP */
 594               	 ;  441 "usb_debug_only.c" 1
 595 00b2 8491      		lpm r24, Z
 596               		
 597               	 ;  0 "" 2
 598               	.LVL43:
 599               	/* #NOAPP */
 600               	.LBE26:
 442:usb_debug_only.c **** 				break;
 443:usb_debug_only.c **** 			}
 444:usb_debug_only.c **** 			len = (wLength < 256) ? wLength : 255;
 601               		.loc 1 444 0
 602 00b4 2F3F      		cpi r18,-1
 603 00b6 3105      		cpc r19,__zero_reg__
 604 00b8 01F0      		breq .L60
 605 00ba 00F0      		brlo .L60
 606 00bc 2FEF      		ldi r18,lo8(-1)
 607 00be 30E0      		ldi r19,0
 608               	.L60:
 609               	.LVL44:
 610 00c0 2817      		cp r18,r24
 611 00c2 00F4      		brsh .L61
 612 00c4 822F      		mov r24,r18
 613               	.LVL45:
 614               	.L61:
 615               	.LBB27:
 616               	.LBB28:
 376:usb_debug_only.c **** 	UEINTX = ~(1<<TXINI);
 617               		.loc 1 376 0
 618 00c6 3EEF      		ldi r19,lo8(-2)
 619               	.LVL46:
 620               	.L66:
 621               	.LBE28:
 622               	.LBE27:
 445:usb_debug_only.c **** 			if (len > desc_length) len = desc_length;
 446:usb_debug_only.c **** 			do {
 447:usb_debug_only.c **** 				// wait for host ready for IN packet
 448:usb_debug_only.c **** 				do {
 449:usb_debug_only.c **** 					i = UEINTX;
 623               		.loc 1 449 0 discriminator 1
 624 00c8 9091 E800 		lds r25,232
 625               	.LVL47:
 450:usb_debug_only.c **** 				} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 626               		.loc 1 450 0 discriminator 1
 627 00cc 292F      		mov r18,r25
 628 00ce 2570      		andi r18,lo8(5)
 629 00d0 01F0      		breq .L66
 451:usb_debug_only.c **** 				if (i & (1<<RXOUTI)) return;	// abort
 630               		.loc 1 451 0
 631 00d2 92FD      		sbrc r25,2
 632 00d4 00C0      		rjmp .L52
 452:usb_debug_only.c **** 				// send IN packet
 453:usb_debug_only.c **** 				n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 633               		.loc 1 453 0
 634 00d6 982F      		mov r25,r24
 635               	.LVL48:
 636 00d8 8132      		cpi r24,lo8(33)
 637 00da 00F0      		brlo .L68
 638 00dc 90E2      		ldi r25,lo8(32)
 639               	.L68:
 640               	.LVL49:
 454:usb_debug_only.c **** 				for (i = n; i; i--) {
 641               		.loc 1 454 0
 642 00de FA01      		movw r30,r20
 643 00e0 292F      		mov r18,r25
 644               	.LVL50:
 645               	.L69:
 646               		.loc 1 454 0 is_stmt 0 discriminator 1
 647 00e2 2223      		tst r18
 648 00e4 01F0      		breq .L107
 649               	.LVL51:
 650               	.LBB30:
 455:usb_debug_only.c **** 					UEDATX = pgm_read_byte(desc_addr++);
 651               		.loc 1 455 0 is_stmt 1 discriminator 2
 652               	/* #APP */
 653               	 ;  455 "usb_debug_only.c" 1
 654 00e6 6491      		lpm r22, Z
 655               		
 656               	 ;  0 "" 2
 657               	.LVL52:
 658               	/* #NOAPP */
 659               	.LBE30:
 660 00e8 6093 F100 		sts 241,r22
 454:usb_debug_only.c **** 				for (i = n; i; i--) {
 661               		.loc 1 454 0 discriminator 2
 662 00ec 2150      		subi r18,lo8(-(-1))
 663               	.LVL53:
 664 00ee 3196      		adiw r30,1
 665               	.LVL54:
 666 00f0 00C0      		rjmp .L69
 667               	.LVL55:
 668               	.L107:
 669 00f2 490F      		add r20,r25
 670 00f4 511D      		adc r21,__zero_reg__
 456:usb_debug_only.c **** 				}
 457:usb_debug_only.c **** 				len -= n;
 671               		.loc 1 457 0
 672 00f6 891B      		sub r24,r25
 673               	.LVL56:
 674               	.LBB31:
 675               	.LBB29:
 376:usb_debug_only.c **** 	UEINTX = ~(1<<TXINI);
 676               		.loc 1 376 0
 677 00f8 3093 E800 		sts 232,r19
 678               	.LBE29:
 679               	.LBE31:
 458:usb_debug_only.c **** 				usb_send_in();
 459:usb_debug_only.c **** 			} while (len || n == ENDPOINT0_SIZE);
 680               		.loc 1 459 0
 681 00fc 8111      		cpse r24,__zero_reg__
 682 00fe 00C0      		rjmp .L66
 683               		.loc 1 459 0 is_stmt 0 discriminator 1
 684 0100 9032      		cpi r25,lo8(32)
 685 0102 01F0      		breq .L66
 686 0104 00C0      		rjmp .L52
 687               	.LVL57:
 688               	.L103:
 460:usb_debug_only.c **** 			return;
 461:usb_debug_only.c ****                 }
 462:usb_debug_only.c **** 		if (bRequest == SET_ADDRESS) {
 689               		.loc 1 462 0 is_stmt 1
 690 0106 8530      		cpi r24,lo8(5)
 691 0108 01F4      		brne .L73
 692               	.LBB32:
 693               	.LBB33:
 376:usb_debug_only.c **** 	UEINTX = ~(1<<TXINI);
 694               		.loc 1 376 0
 695 010a 8EEF      		ldi r24,lo8(-2)
 696               	.LVL58:
 697 010c 8093 E800 		sts 232,r24
 698               	.LBE33:
 699               	.LBE32:
 463:usb_debug_only.c **** 			usb_send_in();
 464:usb_debug_only.c **** 			usb_wait_in_ready();
 700               		.loc 1 464 0
 701 0110 0E94 0000 		call usb_wait_in_ready
 702               	.LVL59:
 465:usb_debug_only.c **** 			UDADDR = wValue | (1<<ADDEN);
 703               		.loc 1 465 0
 704 0114 0068      		ori r16,lo8(-128)
 705               	.LVL60:
 706 0116 0093 E300 		sts 227,r16
 466:usb_debug_only.c **** 			return;
 707               		.loc 1 466 0
 708 011a 00C0      		rjmp .L52
 709               	.LVL61:
 710               	.L73:
 467:usb_debug_only.c **** 		}
 468:usb_debug_only.c **** 		if (bRequest == SET_CONFIGURATION && bmRequestType == 0) {
 711               		.loc 1 468 0
 712 011c 8930      		cpi r24,lo8(9)
 713 011e 01F4      		brne .L74
 714               		.loc 1 468 0 is_stmt 0 discriminator 1
 715 0120 9111      		cpse r25,__zero_reg__
 716 0122 00C0      		rjmp .L75
 469:usb_debug_only.c **** 			usb_configuration = wValue;
 717               		.loc 1 469 0 is_stmt 1
 718 0124 0093 0000 		sts usb_configuration,r16
 719               	.LBB34:
 720               	.LBB35:
 376:usb_debug_only.c **** 	UEINTX = ~(1<<TXINI);
 721               		.loc 1 376 0
 722 0128 8EEF      		ldi r24,lo8(-2)
 723               	.LVL62:
 724 012a 8093 E800 		sts 232,r24
 725               	.LVL63:
 726               	.LBE35:
 727               	.LBE34:
 470:usb_debug_only.c **** 			usb_send_in();
 471:usb_debug_only.c **** 			cfg = endpoint_config_table;
 472:usb_debug_only.c **** 			for (i=1; i<5; i++) {
 728               		.loc 1 472 0
 729 012e 41E0      		ldi r20,lo8(1)
 471:usb_debug_only.c **** 			cfg = endpoint_config_table;
 730               		.loc 1 471 0
 731 0130 80E0      		ldi r24,lo8(endpoint_config_table)
 732 0132 90E0      		ldi r25,hi8(endpoint_config_table)
 733               	.LVL64:
 734               	.L78:
 473:usb_debug_only.c **** 				UENUM = i;
 735               		.loc 1 473 0
 736 0134 4093 E900 		sts 233,r20
 737               	.LBB36:
 474:usb_debug_only.c **** 				en = pgm_read_byte(cfg++);
 738               		.loc 1 474 0
 739 0138 9C01      		movw r18,r24
 740 013a 2F5F      		subi r18,-1
 741 013c 3F4F      		sbci r19,-1
 742               	.LVL65:
 743 013e FC01      		movw r30,r24
 744               	/* #APP */
 745               	 ;  474 "usb_debug_only.c" 1
 746 0140 5491      		lpm r21, Z
 747               		
 748               	 ;  0 "" 2
 749               	.LVL66:
 750               	/* #NOAPP */
 751               	.LBE36:
 475:usb_debug_only.c **** 				UECONX = en;
 752               		.loc 1 475 0
 753 0142 5093 EB00 		sts 235,r21
 476:usb_debug_only.c **** 				if (en) {
 754               		.loc 1 476 0
 755 0146 5523      		tst r21
 756 0148 01F0      		breq .L76
 757               	.LVL67:
 758               	.LBB37:
 477:usb_debug_only.c **** 					UECFG0X = pgm_read_byte(cfg++);
 759               		.loc 1 477 0
 760 014a F901      		movw r30,r18
 761               	/* #APP */
 762               	 ;  477 "usb_debug_only.c" 1
 763 014c 2491      		lpm r18, Z
 764               		
 765               	 ;  0 "" 2
 766               	.LVL68:
 767               	/* #NOAPP */
 768               	.LBE37:
 769 014e 2093 EC00 		sts 236,r18
 770               	.LBB38:
 478:usb_debug_only.c **** 					UECFG1X = pgm_read_byte(cfg++);
 771               		.loc 1 478 0
 772 0152 9C01      		movw r18,r24
 773               	.LVL69:
 774 0154 2D5F      		subi r18,-3
 775 0156 3F4F      		sbci r19,-1
 776               	.LVL70:
 777 0158 3196      		adiw r30,1
 778               	.LVL71:
 779               	/* #APP */
 780               	 ;  478 "usb_debug_only.c" 1
 781 015a 8491      		lpm r24, Z
 782               		
 783               	 ;  0 "" 2
 784               	.LVL72:
 785               	/* #NOAPP */
 786               	.LBE38:
 787 015c 8093 ED00 		sts 237,r24
 788               	.LVL73:
 789               	.L76:
 472:usb_debug_only.c **** 			for (i=1; i<5; i++) {
 790               		.loc 1 472 0
 791 0160 4F5F      		subi r20,lo8(-(1))
 792               	.LVL74:
 793 0162 4530      		cpi r20,lo8(5)
 794 0164 01F0      		breq .L77
 795 0166 C901      		movw r24,r18
 796 0168 00C0      		rjmp .L78
 797               	.L77:
 479:usb_debug_only.c **** 				}
 480:usb_debug_only.c **** 			}
 481:usb_debug_only.c ****         		UERST = 0x1E;
 798               		.loc 1 481 0
 799 016a 8EE1      		ldi r24,lo8(30)
 800 016c 00C0      		rjmp .L105
 801               	.LVL75:
 802               	.L74:
 482:usb_debug_only.c ****         		UERST = 0;
 483:usb_debug_only.c **** 			return;
 484:usb_debug_only.c **** 		}
 485:usb_debug_only.c **** 		if (bRequest == GET_CONFIGURATION && bmRequestType == 0x80) {
 803               		.loc 1 485 0
 804 016e 8830      		cpi r24,lo8(8)
 805 0170 01F4      		brne .L79
 806               		.loc 1 485 0 is_stmt 0 discriminator 1
 807 0172 9038      		cpi r25,lo8(-128)
 808 0174 01F0      		breq .+2
 809 0176 00C0      		rjmp .L53
 486:usb_debug_only.c **** 			usb_wait_in_ready();
 810               		.loc 1 486 0 is_stmt 1
 811 0178 0E94 0000 		call usb_wait_in_ready
 812               	.LVL76:
 487:usb_debug_only.c **** 			UEDATX = usb_configuration;
 813               		.loc 1 487 0
 814 017c 8091 0000 		lds r24,usb_configuration
 815 0180 8093 F100 		sts 241,r24
 816 0184 00C0      		rjmp .L106
 817               	.LVL77:
 818               	.L79:
 488:usb_debug_only.c **** 			usb_send_in();
 489:usb_debug_only.c **** 			return;
 490:usb_debug_only.c **** 		}
 491:usb_debug_only.c **** 
 492:usb_debug_only.c **** 		if (bRequest == GET_STATUS) {
 819               		.loc 1 492 0
 820 0186 8111      		cpse r24,__zero_reg__
 821 0188 00C0      		rjmp .L75
 493:usb_debug_only.c **** 			usb_wait_in_ready();
 822               		.loc 1 493 0
 823 018a 9983      		std Y+1,r25
 824 018c 0E94 0000 		call usb_wait_in_ready
 825               	.LVL78:
 494:usb_debug_only.c **** 			i = 0;
 495:usb_debug_only.c **** 			#ifdef SUPPORT_ENDPOINT_HALT
 496:usb_debug_only.c **** 			if (bmRequestType == 0x82) {
 826               		.loc 1 496 0
 827 0190 9981      		ldd r25,Y+1
 828 0192 9238      		cpi r25,lo8(-126)
 829 0194 01F4      		brne .L90
 497:usb_debug_only.c **** 				UENUM = wIndex;
 830               		.loc 1 497 0
 831 0196 E092 E900 		sts 233,r14
 498:usb_debug_only.c **** 				if (UECONX & (1<<STALLRQ)) i = 1;
 832               		.loc 1 498 0
 833 019a 8091 EB00 		lds r24,235
 834 019e 85FB      		bst r24,5
 835 01a0 8827      		clr r24
 836 01a2 80F9      		bld r24,0
 837               	.LVL79:
 499:usb_debug_only.c **** 				UENUM = 0;
 838               		.loc 1 499 0
 839 01a4 1092 E900 		sts 233,__zero_reg__
 840 01a8 00C0      		rjmp .L80
 841               	.LVL80:
 842               	.L90:
 494:usb_debug_only.c **** 			i = 0;
 843               		.loc 1 494 0
 844 01aa 80E0      		ldi r24,0
 845               	.LVL81:
 846               	.L80:
 500:usb_debug_only.c **** 			}
 501:usb_debug_only.c **** 			#endif
 502:usb_debug_only.c **** 			UEDATX = i;
 847               		.loc 1 502 0
 848 01ac 8093 F100 		sts 241,r24
 503:usb_debug_only.c **** 			UEDATX = 0;
 849               		.loc 1 503 0
 850 01b0 1092 F100 		sts 241,__zero_reg__
 851               	.LVL82:
 852               	.L106:
 853               	.LBB39:
 854               	.LBB40:
 376:usb_debug_only.c **** 	UEINTX = ~(1<<TXINI);
 855               		.loc 1 376 0
 856 01b4 8EEF      		ldi r24,lo8(-2)
 857 01b6 8093 E800 		sts 232,r24
 858 01ba 00C0      		rjmp .L52
 859               	.LVL83:
 860               	.L75:
 861               	.LBE40:
 862               	.LBE39:
 504:usb_debug_only.c **** 			usb_send_in();
 505:usb_debug_only.c **** 			return;
 506:usb_debug_only.c **** 		}
 507:usb_debug_only.c **** 		#ifdef SUPPORT_ENDPOINT_HALT
 508:usb_debug_only.c **** 		if ((bRequest == CLEAR_FEATURE || bRequest == SET_FEATURE)
 863               		.loc 1 508 0
 864 01bc 482F      		mov r20,r24
 865 01be 4D7F      		andi r20,lo8(-3)
 866 01c0 4130      		cpi r20,lo8(1)
 867 01c2 01F0      		breq .+2
 868 01c4 00C0      		rjmp .L53
 509:usb_debug_only.c **** 		  && bmRequestType == 0x02 && wValue == 0) {
 869               		.loc 1 509 0
 870 01c6 9230      		cpi r25,lo8(2)
 871 01c8 01F4      		brne .L81
 872               		.loc 1 509 0 is_stmt 0 discriminator 1
 873 01ca 012B      		or r16,r17
 874 01cc 01F4      		brne .L53
 510:usb_debug_only.c **** 			i = wIndex & 0x7F;
 875               		.loc 1 510 0 is_stmt 1
 876 01ce 2E2D      		mov r18,r14
 877 01d0 2F77      		andi r18,lo8(127)
 878               	.LVL84:
 511:usb_debug_only.c **** 			if (i >= 1 && i <= MAX_ENDPOINT) {
 879               		.loc 1 511 0
 880 01d2 9FEF      		ldi r25,lo8(-1)
 881               	.LVL85:
 882 01d4 920F      		add r25,r18
 883 01d6 9430      		cpi r25,lo8(4)
 884 01d8 00F4      		brsh .L53
 885               	.LBB41:
 886               	.LBB42:
 376:usb_debug_only.c **** 	UEINTX = ~(1<<TXINI);
 887               		.loc 1 376 0
 888 01da 9EEF      		ldi r25,lo8(-2)
 889 01dc 9093 E800 		sts 232,r25
 890               	.LBE42:
 891               	.LBE41:
 512:usb_debug_only.c **** 				usb_send_in();
 513:usb_debug_only.c **** 				UENUM = i;
 892               		.loc 1 513 0
 893 01e0 2093 E900 		sts 233,r18
 514:usb_debug_only.c **** 				if (bRequest == SET_FEATURE) {
 894               		.loc 1 514 0
 895 01e4 8330      		cpi r24,lo8(3)
 896 01e6 01F0      		breq .L53
 515:usb_debug_only.c **** 					UECONX = (1<<STALLRQ)|(1<<EPEN);
 516:usb_debug_only.c **** 				} else {
 517:usb_debug_only.c **** 					UECONX = (1<<STALLRQC)|(1<<RSTDT)|(1<<EPEN);
 897               		.loc 1 517 0
 898 01e8 89E1      		ldi r24,lo8(25)
 899               	.LVL86:
 900 01ea 8093 EB00 		sts 235,r24
 518:usb_debug_only.c **** 					UERST = (1 << i);
 901               		.loc 1 518 0
 902 01ee 81E0      		ldi r24,lo8(1)
 903 01f0 90E0      		ldi r25,0
 904 01f2 022E      		mov r0,r18
 905 01f4 00C0      		rjmp 2f
 906               		1:
 907 01f6 880F      		lsl r24
 908               		2:
 909 01f8 0A94      		dec r0
 910 01fa 02F4      		brpl 1b
 911               	.LVL87:
 912               	.L105:
 913 01fc 8093 EA00 		sts 234,r24
 519:usb_debug_only.c **** 					UERST = 0;
 914               		.loc 1 519 0
 915 0200 1092 EA00 		sts 234,__zero_reg__
 916 0204 00C0      		rjmp .L52
 917               	.LVL88:
 918               	.L81:
 520:usb_debug_only.c **** 				}
 521:usb_debug_only.c **** 				return;
 522:usb_debug_only.c **** 			}
 523:usb_debug_only.c **** 		}
 524:usb_debug_only.c **** 		#endif
 525:usb_debug_only.c **** 		if (bRequest == HID_GET_REPORT && bmRequestType == 0xA1) {
 919               		.loc 1 525 0
 920 0206 8130      		cpi r24,lo8(1)
 921 0208 01F4      		brne .L53
 922               		.loc 1 525 0 is_stmt 0 discriminator 1
 923 020a 913A      		cpi r25,lo8(-95)
 924 020c 01F4      		brne .L53
 526:usb_debug_only.c **** 			if (wIndex == 0) {
 925               		.loc 1 526 0 is_stmt 1
 926 020e EF28      		or r14,r15
 927 0210 01F4      		brne .L53
 928               	.LBB43:
 929               	.LBB44:
 376:usb_debug_only.c **** 	UEINTX = ~(1<<TXINI);
 930               		.loc 1 376 0
 931 0212 3EEF      		ldi r19,lo8(-2)
 932               	.LVL89:
 933               	.L85:
 934               	.LBE44:
 935               	.LBE43:
 527:usb_debug_only.c **** 				len = wLength;
 528:usb_debug_only.c **** 				do {
 529:usb_debug_only.c **** 					// wait for host ready for IN packet
 530:usb_debug_only.c **** 					do {
 531:usb_debug_only.c **** 						i = UEINTX;
 936               		.loc 1 531 0 discriminator 1
 937 0214 8091 E800 		lds r24,232
 938               	.LVL90:
 532:usb_debug_only.c **** 					} while (!(i & ((1<<TXINI)|(1<<RXOUTI))));
 939               		.loc 1 532 0 discriminator 1
 940 0218 982F      		mov r25,r24
 941 021a 9570      		andi r25,lo8(5)
 942 021c 01F0      		breq .L85
 533:usb_debug_only.c **** 					if (i & (1<<RXOUTI)) return;	// abort
 943               		.loc 1 533 0
 944 021e 82FD      		sbrc r24,2
 945 0220 00C0      		rjmp .L52
 534:usb_debug_only.c **** 					// send IN packet
 535:usb_debug_only.c **** 					n = len < ENDPOINT0_SIZE ? len : ENDPOINT0_SIZE;
 946               		.loc 1 535 0
 947 0222 822F      		mov r24,r18
 948               	.LVL91:
 949 0224 2132      		cpi r18,lo8(33)
 950 0226 00F0      		brlo .L86
 951 0228 80E2      		ldi r24,lo8(32)
 952               	.L86:
 953               	.LVL92:
 536:usb_debug_only.c **** 					for (i = n; i; i--) {
 954               		.loc 1 536 0
 955 022a 982F      		mov r25,r24
 956               	.LVL93:
 957               	.L87:
 958               		.loc 1 536 0 is_stmt 0 discriminator 1
 959 022c 9923      		tst r25
 960 022e 01F0      		breq .L108
 537:usb_debug_only.c **** 						UEDATX = 0;
 961               		.loc 1 537 0 is_stmt 1 discriminator 2
 962 0230 1092 F100 		sts 241,__zero_reg__
 536:usb_debug_only.c **** 					for (i = n; i; i--) {
 963               		.loc 1 536 0 discriminator 2
 964 0234 9150      		subi r25,lo8(-(-1))
 965               	.LVL94:
 966 0236 00C0      		rjmp .L87
 967               	.L108:
 538:usb_debug_only.c **** 					}
 539:usb_debug_only.c **** 					len -= n;
 968               		.loc 1 539 0
 969 0238 281B      		sub r18,r24
 970               	.LVL95:
 971               	.LBB46:
 972               	.LBB45:
 376:usb_debug_only.c **** 	UEINTX = ~(1<<TXINI);
 973               		.loc 1 376 0
 974 023a 3093 E800 		sts 232,r19
 975               	.LBE45:
 976               	.LBE46:
 540:usb_debug_only.c **** 					usb_send_in();
 541:usb_debug_only.c **** 				} while (len || n == ENDPOINT0_SIZE);
 977               		.loc 1 541 0
 978 023e 2111      		cpse r18,__zero_reg__
 979 0240 00C0      		rjmp .L85
 980               		.loc 1 541 0 is_stmt 0 discriminator 1
 981 0242 8032      		cpi r24,lo8(32)
 982 0244 01F0      		breq .L85
 983 0246 00C0      		rjmp .L52
 984               	.LVL96:
 985               	.L53:
 542:usb_debug_only.c **** 				return;
 543:usb_debug_only.c **** 			}
 544:usb_debug_only.c **** 		}
 545:usb_debug_only.c ****         }
 546:usb_debug_only.c **** 	UECONX = (1<<STALLRQ) | (1<<EPEN);	// stall
 986               		.loc 1 546 0 is_stmt 1
 987 0248 81E2      		ldi r24,lo8(33)
 988 024a 8093 EB00 		sts 235,r24
 989               	.L52:
 990               	/* epilogue start */
 547:usb_debug_only.c **** }
 991               		.loc 1 547 0
 992 024e 0F90      		pop __tmp_reg__
 993 0250 DF91      		pop r29
 994 0252 CF91      		pop r28
 995 0254 FF91      		pop r31
 996 0256 EF91      		pop r30
 997 0258 BF91      		pop r27
 998 025a AF91      		pop r26
 999 025c 9F91      		pop r25
 1000 025e 8F91      		pop r24
 1001 0260 7F91      		pop r23
 1002 0262 6F91      		pop r22
 1003 0264 5F91      		pop r21
 1004 0266 4F91      		pop r20
 1005 0268 3F91      		pop r19
 1006 026a 2F91      		pop r18
 1007 026c 1F91      		pop r17
 1008 026e 0F91      		pop r16
 1009 0270 FF90      		pop r15
 1010 0272 EF90      		pop r14
 1011 0274 0F90      		pop r0
 1012 0276 0BBE      		out __RAMPZ__,r0
 1013 0278 0F90      		pop r0
 1014 027a 0FBE      		out __SREG__,r0
 1015 027c 0F90      		pop r0
 1016 027e 1F90      		pop r1
 1017 0280 1895      		reti
 1018               		.cfi_endproc
 1019               	.LFE10:
 1021               		.local	previous_timeout.1662
 1022               		.comm	previous_timeout.1662,1,1
 1023               		.local	debug_flush_timer
 1024               		.comm	debug_flush_timer,1,1
 1025               		.local	usb_configuration
 1026               		.comm	usb_configuration,1,1
 1027               		.section	.progmem.data,"a",@progbits
 1030               	descriptor_list:
 1031 0000 0001      		.word	256
 1032 0002 0000      		.word	0
 1033 0004 0000      		.word	device_descriptor
 1034 0006 12        		.byte	18
 1035 0007 0002      		.word	512
 1036 0009 0000      		.word	0
 1037 000b 0000      		.word	config1_descriptor
 1038 000d 22        		.byte	34
 1039 000e 0022      		.word	8704
 1040 0010 0000      		.word	0
 1041 0012 0000      		.word	hid_report_descriptor
 1042 0014 15        		.byte	21
 1043 0015 0021      		.word	8448
 1044 0017 0000      		.word	0
 1045 0019 0000      		.word	config1_descriptor+18
 1046 001b 09        		.byte	9
 1047 001c 0003      		.word	768
 1048 001e 0000      		.word	0
 1049 0020 0000      		.word	string0
 1050 0022 04        		.byte	4
 1051 0023 0103      		.word	769
 1052 0025 0904      		.word	1033
 1053 0027 0000      		.word	string1
 1054 0029 14        		.byte	20
 1055 002a 0203      		.word	770
 1056 002c 0904      		.word	1033
 1057 002e 0000      		.word	string2
 1058 0030 20        		.byte	32
 1061               	string2:
 1062 0031 20        		.byte	32
 1063 0032 03        		.byte	3
 1064 0033 5900      		.string	"Y"
 1065 0035 6F00      		.string	"o"
 1066 0037 7500      		.string	"u"
 1067 0039 7200      		.string	"r"
 1068 003b 2000      		.string	" "
 1069 003d 5500      		.string	"U"
 1070 003f 5300      		.string	"S"
 1071 0041 4200      		.string	"B"
 1072 0043 2000      		.string	" "
 1073 0045 4400      		.string	"D"
 1074 0047 6500      		.string	"e"
 1075 0049 7600      		.string	"v"
 1076 004b 6900      		.string	"i"
 1077 004d 6300      		.string	"c"
 1078 004f 6500      		.string	"e"
 1079 0051 00        		.string	""
 1080 0052 00        		.string	""
 1083               	string1:
 1084 0053 14        		.byte	20
 1085 0054 03        		.byte	3
 1086 0055 5900      		.string	"Y"
 1087 0057 6F00      		.string	"o"
 1088 0059 7500      		.string	"u"
 1089 005b 7200      		.string	"r"
 1090 005d 2000      		.string	" "
 1091 005f 4E00      		.string	"N"
 1092 0061 6100      		.string	"a"
 1093 0063 6D00      		.string	"m"
 1094 0065 6500      		.string	"e"
 1095 0067 00        		.string	""
 1096 0068 00        		.string	""
 1099               	string0:
 1100 0069 04        		.byte	4
 1101 006a 03        		.byte	3
 1102 006b 0904      		.word	1033
 1105               	config1_descriptor:
 1106 006d 09        		.byte	9
 1107 006e 02        		.byte	2
 1108 006f 22        		.byte	34
 1109 0070 00        		.byte	0
 1110 0071 01        		.byte	1
 1111 0072 01        		.byte	1
 1112 0073 00        		.byte	0
 1113 0074 C0        		.byte	-64
 1114 0075 32        		.byte	50
 1115 0076 09        		.byte	9
 1116 0077 04        		.byte	4
 1117 0078 00        		.byte	0
 1118 0079 00        		.byte	0
 1119 007a 01        		.byte	1
 1120 007b 03        		.byte	3
 1121 007c 00        		.byte	0
 1122 007d 00        		.byte	0
 1123 007e 00        		.byte	0
 1124 007f 09        		.byte	9
 1125 0080 21        		.byte	33
 1126 0081 11        		.byte	17
 1127 0082 01        		.byte	1
 1128 0083 00        		.byte	0
 1129 0084 01        		.byte	1
 1130 0085 22        		.byte	34
 1131 0086 15        		.byte	21
 1132 0087 00        		.byte	0
 1133 0088 07        		.byte	7
 1134 0089 05        		.byte	5
 1135 008a 83        		.byte	-125
 1136 008b 03        		.byte	3
 1137 008c 20        		.byte	32
 1138 008d 00        		.byte	0
 1139 008e 01        		.byte	1
 1142               	hid_report_descriptor:
 1143 008f 06        		.byte	6
 1144 0090 31        		.byte	49
 1145 0091 FF        		.byte	-1
 1146 0092 09        		.byte	9
 1147 0093 74        		.byte	116
 1148 0094 A1        		.byte	-95
 1149 0095 53        		.byte	83
 1150 0096 75        		.byte	117
 1151 0097 08        		.byte	8
 1152 0098 15        		.byte	21
 1153 0099 00        		.byte	0
 1154 009a 26        		.byte	38
 1155 009b FF        		.byte	-1
 1156 009c 00        		.byte	0
 1157 009d 95        		.byte	-107
 1158 009e 20        		.byte	32
 1159 009f 09        		.byte	9
 1160 00a0 75        		.byte	117
 1161 00a1 81        		.byte	-127
 1162 00a2 02        		.byte	2
 1163 00a3 C0        		.byte	-64
 1166               	device_descriptor:
 1167 00a4 12        		.byte	18
 1168 00a5 01        		.byte	1
 1169 00a6 00        		.byte	0
 1170 00a7 02        		.byte	2
 1171 00a8 00        		.byte	0
 1172 00a9 00        		.byte	0
 1173 00aa 00        		.byte	0
 1174 00ab 20        		.byte	32
 1175 00ac C0        		.byte	-64
 1176 00ad 16        		.byte	22
 1177 00ae 79        		.byte	121
 1178 00af 04        		.byte	4
 1179 00b0 00        		.byte	0
 1180 00b1 01        		.byte	1
 1181 00b2 01        		.byte	1
 1182 00b3 02        		.byte	2
 1183 00b4 00        		.byte	0
 1184 00b5 01        		.byte	1
 1187               	endpoint_config_table:
 1188 00b6 00        		.byte	0
 1189 00b7 00        		.byte	0
 1190 00b8 01        		.byte	1
 1191 00b9 C1        		.byte	-63
 1192 00ba 26        		.byte	38
 1193 00bb 00        		.byte	0
 1194               		.text
 1195               	.Letext0:
 1196               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 usb_debug_only.c
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:2      *ABS*:0000003e __SP_H__
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:3      *ABS*:0000003d __SP_L__
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:4      *ABS*:0000003f __SREG__
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:5      *ABS*:0000003b __RAMPZ__
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:7      *ABS*:00000001 __zero_reg__
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:13     .text.usb_wait_in_ready:00000000 usb_wait_in_ready
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:36     .text.usb_init:00000000 usb_init
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1024   .bss:00000002 usb_configuration
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:81     .text.usb_configured:00000000 usb_configured
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:99     .text.usb_debug_putchar:00000000 usb_debug_putchar
                             .bss:00000000 previous_timeout.1662
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1022   .bss:00000001 debug_flush_timer
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:221    .text.usb_debug_flush_output:00000000 usb_debug_flush_output
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:269    .text.__vector_10:00000000 __vector_10
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:374    .text.__vector_11:00000000 __vector_11
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1030   .progmem.data:00000000 descriptor_list
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1187   .progmem.data:000000b6 endpoint_config_table
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1166   .progmem.data:000000a4 device_descriptor
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1105   .progmem.data:0000006d config1_descriptor
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1142   .progmem.data:0000008f hid_report_descriptor
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1099   .progmem.data:00000069 string0
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1083   .progmem.data:00000053 string1
/var/folders/8r/0fdlnc995dl_vxqd6srx06ch0000gn/T//ccVFKwv2.s:1061   .progmem.data:00000031 string2

UNDEFINED SYMBOLS
__do_clear_bss
